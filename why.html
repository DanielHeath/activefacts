<!--#include virtual="/header.html" -->

  <div class="content">
      <h2>Why Semantic Modeling?</h2>

      <p>
      Software is not mainly about <em>how</em>, but about <em>what</em> and
      <em>why</em>. Software projects fail most commonly because they build
      the <em>wrong thing</em>, not because they build it wrongly.  Other
      forms of modeling, such as object modeling and entity relationship
      modeling, attempt to capture <em>what</em>, but the models are shaped
      from the start by the needs of implementation (<em>how</em>).  That
      shuts out the non-technical business expert, and bends the model out
      of shape, losing track of <em>why</em> each feature is needed, what it
      means and under what terms, the roles it plays in the overall system.
      <strong>Semantic modeling</strong> incorporates and transcends both
      approaches, and works in either Agile or traditional environments.
      </p>

      <p>
      ActiveFacts uses a <strong>fact-oriented</strong> approach to
      constructing models in <strong>elementary</strong> form. Every
      concept, whether a business entity or a relationship, is represented
      in the simplest possible form, isolated from all other concerns.
      Every role that each concept plays in the system is incorporated in
      simple <strong>business rules</strong> that can be effectively
      verbalised in plain language, displayed on diagrams, and managed in a
      system ontology (vocabulary).  The elementary form is the most direct
      mind-map of the business domain that can be constructed, is based on
      pure logic, and is unsullied by implementation concerns. That makes it
      much easier to understand and validate by all parties, especially the
      business expert. Purely for its benefits in specification, semantic
      modeling is revolutionary.
      </p>

      <p>
      Because the semantic approach is based in pure logic, it can be
      automatically <strong>transformed</strong> into working software,
      in the form of executable code and database designs in efficient
      normalised form.  It's an established truth that very small changes
      (even additions) in business rules can require large changes to
      the structure of an database.  Contrary to existing methods used
      to design and access databases, semantic modeling allows you to
      make radical changes in the underlying physical table structures
      without the huge ramifications in your application code. The
      advantages in business agility are manifold.
      </p>

      <!--p>
      Queries in CQL span tables transparently, crossing conceptual
      relationships (fact types) without explicit database joins, and
      return structured data in a nested-relational form (called
      constellation form). For every user action in an application, a
      single query can be defined that provides all the data required to
      respond to that action.  There's no need to fetch this, that, and
      the other. All required results are fetched at once, which
      improves application structure, performance, and even concurrency.
      </p-->

<!--#include virtual="/footer.html" -->
