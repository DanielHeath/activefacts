	Constellation Ruby Runtime API Proposal.
	Clifford Heath. (c) Copyright 2008.

Notes:
======

1) The API makes widespread of proxy objects to access an underlying
object from a given point-of-view, adding a few extra methods. This
might be a performance issue with the number of small objects?
Careful programming will allow the same proxies to be re-used.

2) Concept here means any ValueType, EntityType, or objectified
FactType (whether objectified explicitly or implicitly). Each
Concept is represented by a Ruby class with extensions.
Instance means an instance of any Concept.

3) All Concepts and Instances support the verbalise method.
All Concepts support the vocabulary method.
All Instances have a single method for each role played by the Concept.
All Instances support the class method (which returns the Concept).
All Instances support the constellation method.
All Instances support the query method (perhaps class could be
rolled in under this?).

4) No fact objects are created for binary functional dependencies.
This means the API isn't immune to changes in uniqueness that affect
FDs, because a role will go from single-valued to multi-valued, and
those have a different API.

5) No representation of constraints is shown here yet.

6) There's mixed data and metadata for the query API, which needs to
be teased apart.

7) This API, instantiated for the Metamodel, is the design-time API.


Instance:
	#verbalise() -> Return CQL definition for concept instance, see below
	#class() -> Return the Concept class
	#query() -> Return the QueryVariable for the role player of the invoked fact type
	#constellation() -> Return the Constellation this instance belongs to

	#<role_name>=(v) ->
	For an FD role, assign the value
	For a non-FD Role: REVISIT: What to do here, assign an array?

	#<role_name>() ->
	For a FD Role:
		FactProxy for the associated FactType

	For a non-FD Role:
		FactSetProxy (a proxy to an array of FactProxies)

Value Instance (use String, Integer, Date, etc?):
	#verbalise() -> Return "#{self.class.name} #{inspect}"

Entity Instance (normal Class):
	#verbalise() -> Return CQL definition for concept
		e.g. "Person = entity known by given-Name 'Fred' and family-Name 'Fly'"

FactSetProxy
	#focus() -> The Instance from which this FactSet was reached
	#size -> the number of facts in the set
	#[n] -> the nth fact in the set
	#mutable (or .static?) -> boolean saying whether this set may be changed
	#add(...) -> to be defined

FactProxy: (Proxy for a fact viewed from one of its players)
	#focus() -> The Instance from which this Fact was reached
	#delete() -> Delete this Fact
	#original() -> The original values of an FD role player
	#role()[n] ->
	#<role_name>() -> A RoleProxy for the instance that plays the specified role
	#all methods for the player of the other role of a binary fact, if __focus() set.

RoleProxy:
	=(v) -> Assign a new value to the instance that plays this role
	#all methods of this instance

Fact:
	#verbalise() -> e.g. "Person has given-Name 'Fred'"
	#class() -> Return the FactType class
	#query() -> Return the QueryFactType for the invoked fact type
	#constellation() -> Return the Constellation for this query invocation
	#<role_name> -> Return the role player
	Following methods might be qualified by ".fact.<method>"...? (how?)
	#player()[n] -> Access the role players
	#original()[n] -> original value of role player
	#is_changed() -> TRUE if value != original
	#delete() -> remove this fact (un-play all players)

Constellation:
	#query() -> Return the Query head node
	#session() -> Return the database Session we were fetched from
	#transaction() -> Return the transaction sequence-number when we were fetched
	#validate_internal() -> Do all possible validity checks before saving
	#save() -> Save all changes
	#digest() -> Return a unique digest of all content
	... (all required indexes, etc).

Metadata objects
================

Vocabulary:
	#constraints()
	...

Concept:
	#verbalise() -> Return CQL definition for concept
	#vocabulary() -> Return the Vocabulary object
	#role()[n] -> Return the nth role

FactType:
	#verbalise() -> Return CQL definition for fact type
	#vocabulary() -> Return the Vocabulary object
	#role()[n] -> Return the nth role
	#reading()[n] -> Access the readings

Query objects
=============

Query:
	#verbalise() -> Return CQL definition for query
	#vocabulary() -> Return the Vocabulary object
	#fact_types()[n] -> Return a QueryFactType from the array
	#variables()[] -> Return a QueryVariable from the array

QueryVariable:
	#concept() -> The Concept which plays the roles of this variable
	#each() -> Iterate over all distinct instances in this constellation
	#adjective() -> adjective to disambiguate this variable ("-" in front or back)

QueryFactType:
	#fact_type() -> the FactType being invoked
	#variables()[] -> QueryVariables that play a part in this FactType invocation
	#negative() -> The query is satisfied only if no fact instances match
	#aggregation() -> identifies form of aggregation over the fact population
	#each() -> Iterate over all distinct facts in this constellation

QueryCondition: (Comparison operator between two expressions)
	...

QueryExpression:
	...

Examples
========

For example, if you have:
	Order = entity known by Id;
	...
	Line = entity known by Order and Ordinal-line;
	Line is for Product;
	Line is for Quantity;
	Line costs total-Amount;
	Order has many Line;

To insert, run a query against the empty population, yielding
a blank constellation into which you can insert, then save.

After fetching an order, you'd be able to write:

	line = some_order.line.add()	# some_order is implicit player, ordinal is auto-assigned
	line.product = some_product
	line.quantity = 10
	line.total_amount = 24.3
	...
	line.constellaton.save

or maybe even:

	some_order.line.add(:product => some_product, :quantity => 10, total_amount = 24.3)

Traversal within the constellation:
	e.g. order.line[0].line.product.id (etc).
	The 2nd .line may be omitted here for binaries as the FactProxy has an implicit Role

