#
#       ActiveFacts CQL Parser.
#       Parse rules relating to FactType definitions.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    grammar FactTypes
      rule named_fact_type
        s term_definition_name
        s is s mapping_pragmas where    # REVISIT: Need a place to put mapping pragmas like [independent]
        anonymous_fact_type
        {
	  def ast
	    ft = anonymous_fact_type.ast
	    ft.name = term_definition_name.value
	    ft
	  end
        }
      end

      rule anonymous_fact_type
        fact_clause
          ftail:( (',' / and ) s fact_clause s )*
          ctail:( (':' / where) s c:conditions s)?
          returning_clause?
        s ';'
        {
	  def ast
            readings = [fact_clause.ast, *ftail.elements.map{|e| e.fact_clause.ast }]
            conditions = !ctail.empty? ? ctail.c.ast : []
	    returning = respond_to?(:returning_clause) ? returning_clause.ast : nil
	    if (conditions.empty? && readings.detect{|r| r.includes_literals})
	      raise "Fact instances may not contain conditions" unless conditions.empty? && !returning
	      Compiler::Fact.new readings
	    elsif (readings.size == 1 &&
	      readings[0].phrases.size == 1 &&
	      (popname = readings[0].phrases[0]) &&
	      !popname.is_a?(Compiler::RoleRef) &&
	      conditions.detect{|r| r.includes_literals}
	    )
	      Compiler::Fact.new conditions, popname
	    else
	      Compiler::FactType.new nil, readings, conditions, returning
	    end
	  end
        }
      end

      rule returning_clause
        returning return (',' return)*
      end

      rule return
        by order 'REVISIT: return'
      end

      rule conditions
        head:condition s tail:( (',' s / and S) next:condition s )*
        {
	  def ast
	    [head.ast, *tail.elements.map{|i| i.next.ast}]
	  end
        }
      end

      rule condition
        head:clause s # tail:(or S alternate:clause s )*
        {
	  def ast
	    head.ast
            # Compiler::Alternates.new(head.ast, *tail.elements.map{|i| i.alternate.ast})
	    # REVISIT: alternate conditions are not yet implemented
	  end
        }
      end

      rule clause
        # REVISIT: No context for comparisons, yet
        comparison / fact_clause
      end

      rule fact_clause
        s q:qualifier? s reading s p:post_qualifiers? s c:context_note?
        {
	  def ast
	    qualifiers = (q.empty? ? [] : [ q.text_value ]) +
	      (p.empty? ? [] : p.list)
	    # REVISIT: When we implement objectification joins, we might get multiple readings here...
	    r = reading.ast
	    r.qualifiers << q.text_value unless q.empty?
	    r.qualifiers += p.list unless p.empty?
	    r.context_note = c.ast unless c.empty?
	    r
	  end
        }
      end

      rule qualifier
        maybe / definitely
      end

      rule post_qualifiers
        '[' s q0:post_qualifier tail:( s ',' s q1:post_qualifier )* s ']' s
        {
          def list
            [q0.text_value, *tail.elements.map{|e| e.q1.text_value}]
          end
        }
      end

      rule post_qualifier
        static / transient / intransitive / transitive / acyclic / symmetric
      end

      rule reading
        (
          role    # A role reference containing a term, perhaps with attached paraphernalia
          /       # A hyphenated non-term. Important: no embedded spaces
          id tail:('-' !term id)+ s
            {
	      def ast
		[id.value, *tail.elements.map{|e| e.id.value}]*"-"
	      end
	    }
          /       # A normal non-term
          !non_role_word id s
	    {
	      def ast
		id.value
	      end
	    }
        )+
        {
	  def ast
	    Compiler::Reading.new(elements.map{ |r| r.ast })
	  end
        }
      end

      # This is the rule that causes most back-tracking. I think you can see why.
      # When we have an expression, we will come down here perhaps multiple times,
      # but find no way out as soon as we hit the trailing non_role.
      rule role
        q:(quantifier enforcement)?
        player:term
        func:function_call? s
        role_id:(role_name / subscript )?
        lr:( literal / restriction enforcement )?
	oj:objectification_join?
        !non_role     # If we integrate fact_clauses with comparisons, this can go.
        {
	  def ast
	    if !q.empty? && q.quantifier.value
	      quantifier = Compiler::Quantifier.new(q.quantifier.value[0], q.quantifier.value[1], q.enforcement.ast)
	    end
	    role_name = role_id.empty? ? nil : role_id.value
	    function_call = nil
	    if !lr.empty?
	      literal = lr.value if lr.respond_to?(:value)
	      restriction = Compiler::ValueRestriction.new(lr.restriction.ranges, lr.enforcement.ast) if lr.respond_to?(:restriction)
	    end

	    raise "REVISIT: Objectification joins #{oj.text_value} are not yet implemented" unless oj.empty?

	    player.ast(quantifier, function_call, role_name, restriction, literal)
	  end
        }
      end

      rule objectification_join
        '(' s where s fact_clause s ')' s
      end

      rule role_name
        '(' s as S r:term s ')' s
        { def value; r.value; end }
      end

      rule subscript
        '(' s i:([1-9] [0-9]*) s ')' s 
        { def value; i.text_value.to_i; end }
      end

      rule non_role
        # Any of these is illegal in or following a reading (they indicate a comparison is coming). Later, this will change:
        comparator
        / add_op
        / mul_op
      end

    end
  end
end
