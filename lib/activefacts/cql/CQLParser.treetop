module ActiveFacts
  grammar CQL
    include LexicalRules
    include Language        # One of the language modules provides this module
    include Expressions
    include Concepts
    include DataTypes
    include FactTypes

    rule cql_file
      s seq:definition*
      {
        def definitions
          seq.elements.map{|e|
              e.value rescue $stderr.puts "Can't call value() on #{e.inspect}"
            }
        end
        def inspect
          definitions.map{|d|
              d.inspect
            }*"\n"
        end
        def compile
          definitions.each{|d|
              p d
            }
        end
      }
    end

    # Each definition has a value method that returns an array like
    # either [name, [kind, definition]] or [name, kind]:
    rule definition
      vocabulary_definition
      / import_definition
      / constraint
      / concept
    end

    rule vocabulary_definition
      vocabulary S id s ';' s
      {
        def value
          [ id.text_value, [ :vocabulary ] ]
        end
      }
    end

    rule import_definition
      import S id alias_list ';' s
      {
        def value
          puts "import #{id.text_value}: not implemented"
          [ id.text_value, [ :import ] ]
        end
      }
    end

    # REVISIT: Need a way to define equivalent readings for fact types here (and in the metamodel)
    rule alias_list
      ( s ',' s alias S aliased:id S as S alias:id s )*
    end

    rule constraint
      (
	( 'for' s 'each' s role_list s quantifier s 'of' s 'these' s 'holds' s ':' s
	/ 'each' s role_list s 'occurs' s quantifier s 'time' s 'in' s
	)
	reading ( s ',' s reading )*
#	/
#	s reading s 'only' s 'if' s reading
      )
      s ';' s
      {
	def value
	  [ nil, [ :constraint, "NOT IMPLEMENTED" ] ]
	end
      }
    end

  end
end
