module ActiveFacts
  grammar CQL
    include LexicalRules
    include Language        # One of the language modules provides this module
    include Expressions
    include Concepts
    include DataTypes
    include FactTypes

    rule cql_file
      s seq:definition*
      {
        def definitions
          seq.elements.map{|e|
              e.value rescue $stderr.puts "Can't call value() on #{e.inspect}"
            }
        end
      }
    end

    # Each definition has a value() method that returns an array like
    # either [name, [kind, definition]] or [name, kind]:
    rule definition
      vocabulary_definition
      / import_definition
      / constraint
      / concept
    end

    rule vocabulary_definition
      vocabulary S id s ';' s
      {
        def value
          [ id.text_value, [ :vocabulary ] ]
        end
      }
    end

    rule import_definition
      import S id alias_list ';' s
      {
        def value
          puts "import #{id.text_value}: not implemented"
          [ id.text_value, [ :import ], alias_list.value ]
        end
      }
    end

    # REVISIT: Need a way to define equivalent readings for fact types here (and in the metamodel)
    rule alias_list
      ( s ',' s alias S aliase_from:id S as S alias_to:id s )*
      {
        def value
          elements.inject({}){|h, e| h[e.aliase_from.text_value] = e.alias_to; h }
        end
      }
    end

    rule constraint
      subset_constraint /
      equality_constraint /
      for_each_constraint /
      each_constraint
    end

    rule for_each_constraint
      'for' s 'each' s role_list s quantifier s 'of' s 'these' s 'holds' s ':' s
      readings_list s
      ';' s
      { def value; [ nil, [ :constraint, "NOT IMPLEMENTED" ] ]; end }
    end

    rule each_constraint
      'each' s role_list s 'occurs' s quantifier s 'time' s 'in' s
      readings_list s
      ';' s
      { def value; [ nil, [ :constraint, "NOT IMPLEMENTED" ] ]; end }
    end

    rule subset_constraint
      reading s only s if s reading s ';' s
      { def value; [ nil, [ :constraint, "NOT IMPLEMENTED" ] ]; end }
    end

    rule equality_constraint
      reading s if s and s only s if s reading s ';' s
      { def value; [ nil, [ :constraint, "NOT IMPLEMENTED" ] ]; end }
    end

    rule readings_list
      readings ( ',' s readings )*
    end

    rule readings
      reading s ( and s reading s )*
    end

  end
end
