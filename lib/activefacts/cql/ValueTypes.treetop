#
#       ActiveFacts CQL Parser.
#       Parse rules relating to ValueType definitions.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    grammar ValueTypes
      rule value_type
        s term_definition_name
	# REVISIT: ORM2 would allow (subtype_prefix term)?
        written_as
        base:(term/id) s
        value_type_parameters
        units
        r:(restriction enforcement)?
        mapping_pragmas
        s ';' s
        {
	  def ast
	    name = term_definition_name.value
	    params = value_type_parameters.values
	    restriction = r.empty? ? nil : Compiler::Restriction.new(r.restriction.ranges, r.enforcement.value)
	    Compiler::ValueType.new name, base.value, params, units.value, restriction, mapping_pragmas.value
	  end

          def defined_type
            [
              :value_type,
              base.value,
              value_type_parameters.values,
              units.value,
              (!r.empty? ? r.restriction.ranges : []),
              mapping_pragmas.value,
              (!r.empty? ? r.enforcement.value : nil)
            ]
          end

          def value
            [ term_definition_name.value,
              defined_type
            ]
          end
        }
      end

      rule value_type_parameters
        '(' s tpl:type_parameter_list? ')' s
          { def values; tpl.empty? ? [] : tpl.values; end }
        / s
          { def values; []; end }
      end

      rule type_parameter_list
        head:number s tail:( ',' s number s )*
        {
          def values
            [head.value, *tail.elements.map{|i| i.number.value}]
          end
        }
      end

      rule unit_definition
        u:(
          unit_coefficient units s o:unit_offset?
          converts s a:(approximately s)? to s
          singular:id s plural:('/' s p:id s)?
        /
          singular:id s plural:('/' s p:id s)?
          converts s a:(approximately s)? to s
          unit_coefficient units s o:unit_offset?
        )
        q:(approximately '' / ephemeral '')? s
        ';' s
        {
	  def ast
            singular = u.singular.text_value
            plural = u.plural.text_value.empty? ? nil : u.plural.p.text_value 
            numerator, denominator = *u.unit_coefficient.ast
            offset = u.o.text_value.empty? ? 0 : u.o.value
            bases = u.units.value
	    approximately = q.respond_to? :approximately
	    ephemeral = q.respond_to? :approximately
	    Compiler::Unit.new singular, plural, numerator, denominator, offset, bases, approximately, ephemeral
	  end

	  def value
            r = { :coefficient => u.unit_coefficient.value,
                  :offset => u.o.text_value.empty? ? 0 : u.o.value,
                  :base => u.units.value,
                  :singular => u.singular.text_value,
                }
            r[:plural] = u.plural.p.text_value unless u.plural.text_value.empty?
            r[:approximately] = true if q.text_value == 'approximately' || !u.a.text_value.empty?
            r[:ephemeral] = true if q.text_value == 'ephemeral'
            [ nil, [ :unit, r ] ]
          end
        }
      end

      rule unit_coefficient
        numerator:number denominator:(s '/' s number)? s
        {
	  def ast
            [ numerator.text_value,
              (denominator.text_value.empty? ? "1" : denominator.number.text_value)
	    ]
	  end

	  def value
            { :numerator => numerator.text_value,
              :denominator => (denominator.text_value.empty? ? "1" : denominator.number.text_value)
            }
          end
        }
      end

      rule unit_offset
        sign:[-+] s number s
        { def value
            sign.text_value == '-' ? "-"+number.text_value : number.text_value
          end
        }
      end

      rule units
        '' u:(!non_unit unit s tail:(!non_unit unit s)* div:('/' s unit s tail:(!non_unit unit s)*)?)?
        { def value
            if u.text_value.empty?
              []
            else
              u.tail.elements.inject([u.unit.value]) { |a, e| a << e.unit.value } +
                (u.div.text_value.empty? ? [] : u.div.tail.elements.inject([u.div.unit.inverse]) { |a, e| a << e.unit.inverse })
            end
          end
        }
      end

      rule non_unit
        restricted / converts / approximately / ephemeral
      end

      rule unit
        unit_name:id pow:('^' '-'? [0-9])?
        { def value
            [unit_name.text_value, pow.text_value.empty? ? 1 : Integer(pow.text_value[1..-1])]
          end
          def inverse
            a = value
            a[1] = -a[1]
            a
          end
        }
      end

      rule restriction
	restricted s to s range_list s units
        {
          def ranges
            range_list.ranges   # REVISIT: Use the units here
          end
        }
      end

      rule range_list
        '{' s
          head:range s tail:( ',' s range )*
        '}' s
        {
          def ranges
            [head.value, *tail.elements.map{|e| e.range.value }]
          end
        }
      end

    end
  end
end
