#
#       ActiveFacts CQL Parser.
#       Parse rules relating to Concept definitions.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    grammar Concepts
      rule concept
        value_type
        / entity_type
        / named_fact_type
        / anonymous_fact_type
      end

      rule entity_type
        s term_definition_name
        sup:(basetype / subtype)
	  &{|s|
	    # There's an implicit type when we use an identification mode, register it:
	    mode = (i = s[2].identifier) && Hash === i && i[:mode]
	    input.context.object_type(s[1].value+mode, "identification mode type") if mode
	    true
	  }
        mapping_pragmas
        ec:entity_conditions?
        ';' s
        {
          def defined_type
            [ :entity_type, sup.supers, sup.identifier, mapping_pragmas.value, (ec.empty? ? nil : ec.conditions) ]
          end

          def value
            [ term_definition_name.value,
              defined_type
            ]
          end
        }
      end

      rule basetype
        is s
        # independency?
        identification
        { def supers; [] end
          def identifier; identification.value; end
        }
      end

      rule subtype
        subtype_prefix
        # independency?
        supertype_list ident:identification?
        {
          def supers; supertype_list.value; end
          def identifier; ident.empty? ? nil : ident.value; end
        }
      end

      # REVISIT: This doesn't work, and I don't know why.
      rule independency
         ('independent' S / 'separate' S / 'partitioned' S)
      end

      rule supertype_list
        primary:id s
        alternate_supertypes:( ',' s !identified_by name:id s )*
        { def value; alternate_supertypes.elements.inject([primary.value]) { |a, sup| a << sup.name.value }; end }
      end

      rule identification
        # REVISIT: Consider distinguishing "-Id" from just "Id", and not prepending the entity type name if no "-"
        identified_by its s i:(term/id) value_type_parameters
	r:(restriction enforcement)?          # Reference Mode; restriction may be needed for the ValueType
          { def value
	      { :mode => i.value,
	        :restriction => (r.text_value.empty? ? nil : r.restriction.ranges),
	        :enforcement => (r.text_value.empty? ? nil : r.enforcement.value),
		:parameters => value_type_parameters.values
	      }
	    end
	  }
        /
        identified_by role_list
	  &{|s|
	    forwards = s[-1].roles.map do |phrase|
		next nil if phrase.size != 1  # Can only forward-reference simple terms.
		next nil if (term = phrase[0])[:leading_adjective] or term[:trailing_adjective]
		term[:term]
	      end.compact
	    input.context.allowed_forward_terms(forwards)
	    true
	  }
          { def value; {:roles => role_list.roles }; end }
      end

      # Identified by roles... also used for constraints, beware
      rule role_list 
        head:term_or_unary s tail:( ( and S / ',' s ) term_or_unary s )*
        { def roles
            tail.elements.inject([head.value]) { |a, e| a << e.term_or_unary.value }
          end
        }
      end

      rule term_or_unary
	pre_text:(s !non_role_word !term id)* s term post_text:(s !non_role_word !term id)*
	  { def value
	      pre_text.elements.map {|w| w.id.text_value } +
	      [ term.structure ] +
	      post_text.elements.map {|w| w.id.text_value }
	    end
	  }
	/
	s !non_role_word id s &non_role_word
	  {
	    def value
	      [{:term => id.text_value}]
	    end
	  }
      end

      rule mapping_pragmas
        '[' s h:mapping_pragma t:(s ',' s mapping_pragma)* s ']' s
          { def value; t.elements.inject([h.value]) { |a, e| a << e.mapping_pragma.value }; end }
        /
        ''
          { def value; []; end }
      end

      rule mapping_pragma
        (independent / separate / partitioned / personal / feminine / masculine)
          { def value; text_value; end }
      end

      rule entity_conditions
        (':' / where) s c:conditions?
        {
          def conditions
            c.empty? ? [] : c.condition_list
          end
        }
      end

    end
  end
end
