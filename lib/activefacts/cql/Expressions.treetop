#
#       ActiveFacts CQL Parser.
#       Parse rules relating to Expressions
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
module ActiveFacts
  module CQL
    grammar Expressions
      rule expression
        sum
      end

      rule sum
        t0:product s tail:( op:add_op s t1:product s )*
        {
	  def ast
	    if tail.elements.empty?
	      t0.ast
	    else
	      Compiler::Sum.new(t0.ast, *tail.elements.map{|e| e.op.text_value == '-' ? Compiler::Negate.new(e.t1.ast) : e.t1.ast})
	    end
	  end
        }
      end

      rule add_op
        '+' / '-'
      end

      rule product
        f0:factor s tail:( op:mul_op s f1:factor s )*
        {
	  def ast
	    if tail.elements.empty?
	      f0.ast
	    else
	      Compiler::Product.new(f0.ast, *tail.elements.map{|e| e.op.text_value != '*' ? Compiler::Reciprocal.new(e.op.text_value, e.f1.ast) : e.f1.ast})
	    end
	  end
        }
      end

      rule factor
        literal u:unit? s
            {
	      def ast
		Compiler::Literal.new(literal.value, u.empty? ? nil : u.text_value)
	      end
            }
        / derived_variable
        / !context_note '(' s sum s ')' s                   { def ast; sum.ast; end }
      end

      rule derived_variable
        variable:term s p:function_call* role_id:(role_name / subscript )?
        {
	  def ast quantifier = nil, value_constraint = nil, literal = nil, objectification_join = nil
	    role_name = role_id.empty? ? nil : role_id.value
	    var = variable.ast(quantifier, nil, role_name, value_constraint, literal, objectification_join)
	    if p.empty?
	      var
	    else
	      Compiler::FunctionCallChain.new(var, *p.elements.map{|f| f.ast})
	    end
	  end
        }
      end

      rule function_call
        '.' s func:id s param_list:( '(' s params:( p0:expression s tail:( ',' s p1:expression s )* )? ')' s )?
        {
	  def ast
	    if param_list.empty? || param_list.params.empty?
	      params = []
	    else
	      params = [param_list.params.p0.ast] + param_list.params.tail.elements.map{|param| param.p1.ast }
	    end
	    Compiler::FunctionCall.new(func.value, *params)
	  end
        }
      end

    end
  end
end
