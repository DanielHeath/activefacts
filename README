ActiveFacts
-----------

Clifford Heath, 3 March 2008

The ActiveFacts project lives on RubyForge, with source
code access details here:
<http://rubyforge.org/scm/?group_id=3253>.

Status messages go to the Yahoo information_modeling
group, which is also available as an NNTP feed on Gmane,
news:gmane.comp.programming.modeling.information.

What is Semantic (Fact-based) modeling?
---------------------------------------

Semantic-based information modeling is a form of conceptual
modeling that operates at a higher level than either UML
(and other object modeling approaches) or traditional ER
(entity-relationship) data modeling. It uses natural
verbalisations to define information in terms of concepts
(value types and entity types) and elementary fact types
(relationships between concepts).

A fact type in elementary form cannot be broken down into
smaller parts. Each fact type uses natural verbalisation,
and the combination of these two make fact-based models
easier to understand than any other kind of information
model. Because it's easier to understand, it's easier to
directly check and verify with business domain experts.
The main benefit of the fact-based approach is the
confidence that you're building the right software.

While defining the structure of your information, it's
important also to add constraints that restrict the
possible data. The most common case is to add uniqueness
constraints, which are used to define requirements like
each person having only one family name. These constraints
can be further checked through the use of sample data. A
variety of standard constraint types gives the designer
flexibility in defining the business rules. Again, the
constraints are expressed in natural English and may
be checked directly by the business expert.

An automatic process transforms any semantic model into an
efficient database design in third normal form, and also
generates code (object-oriented class libraries) to
create, access and update that database.  The designer
does not need to know SQL or how to normalize a database
design.

It's also possible to express queries using the semantic
model, which can be automatically translated into queries
against the SQL database, and the results transformed back
into the conceptual form. No such conceptual query language
has become widely used, but ActiveFacts introduces the
Constellation Query Language.

Why ActiveFacts?
----------------

Previously, semantic modeling has only been used as a
design techique for databases. ActiveFacts takes it to a
new level, by providing a semantic runtime.  Your programs
don't have to be written in SQL, and so are freed from
dependence on the physical storage structures produced
during the normalisation process. The ability to isolate
the code from the physical structure has big benefits when
your requirements change, because the consequences of any
change only affects that part of your code, and don't leak
into the rest of the application.  It's also possible (and
beneficial!) to use ActiveFacts to design programs that
don't use a database at all.

For every user action in any application, a single query
can be defined that provides all the data required to
respond to that action. There's no need to execute
multiple queries, fetching this, that, and the other. All
required results are fetched at once, which improves
application structure, performance, and even concurrency.
These result "constellations" may be modified in memory
and saved to the database in larger transactions. The
application naturally falls into a service-oriented (or
REST) architecture.

So in summary, using ActiveFacts, you can:

a) be sure you're building the right software earlier

b) structure your application better

c) change the information model with less rework

d) provide easy ad-hoc query facilities

Status
------

ActiveFacts can read models created in two ways. You can
use NORMA, the Neumont Object Role Modeling Architect,
to produce a model as an ORM2 diagram, or you can write
CQL (Constellation Query Language) statements. NORMA
models can be converted to CQL. At the time of writing,
the CQL language isn't fully implemented. Finally, tools
are in progress to reverse-engineer an existing relational
database into the conceptual form.

You can generate a Ruby API (which uses the ActiveFacts
Constellation API as a basis) from any semantic model. The
generated API makes it possible to create any information
structure (fact population) allowed by that model.
Database Persistence features are not yet implemented for
the Constellation API.

ActiveFacts has a meta-model created in NORMA which
defines what a semantic model may contain. This metamodel
has been converted to an API, and this API will become the
basis for the other ActiveFacts tools. This will complete
the full bootstrap.  The meta-model has also been manually
mapped to a relational schema. After further refinement
this will allow any semantic model to be retrieved,
manipulated and stored in a database.

Download and play
-----------------

To look at ActiveFacts, install Subversion (either
<http://subversion.tigris.org/> or one of the bundles
like Tortoise SVN, cygwin, etc), and issue the checkout
instruction on the RubyForge webpage listed above.
You can also browse the files online at
<http://rubyforge.org/scm/?group_id=3253>.

My NORMA models are checked into the "examples/norma"
directory, and "examples/pdf" contains PDF versions of
all the model diagrams, so folk who don't have NORMA
or VS2005 can look at them. Images, CQL and Ruby code
derived form these models is also published.

Many of the models are simple, but there are several
real-life models there.

Though the provided models are mostly simple, ActiveFacts
has successfully reverse-engineered some large commercial
database schemas, including ManageSoft (265 tables).

If you have Ruby installed <www.ruby-lang.org> you can
load a NORMA model using the command:

ruby -Ilib bin/norma.rb MyModel.orm

read_norma simply reads a NORMA file and spits out some
textual notes so you can see it's understood it.

Use the --cql option to see the model as CQL:

ruby -Ilib bin/norma.rb --cql examples/norma/Orders.orm

The --ruby option emits code for the new API.

If you also have ActiveRecord, DRYSql (patched with the
patches provided) and CPK (composite primary keys),
you can reverse engineer your own schema:

ruby -I lib bin/reflect.rb --dsn=Orienteering \
	--adapter=sqlserver --mode=ODBC --user=sa
	--password=

... or whatever ActiveRecord connection options are
appropriate to connect to your database.

NORMA
-----

NORMA is the latest in a line of products (stretching back
two decades) which implement the Object Role Modeling, ORM.
ORM, a fact based modeling notation, is now in version 2.
NORMA is open source, a design tool that runs within
Microsoft Visual Studio 2005 - Professional Edition. The
Express Edition doesn't have require DSL Tools support.

You can download the latest version of NORMA (and source
code, if you wish) from <http://sourceforge.net/orm>. For
more about ORM2, see <http://www.orm.net> and other
resources.

Notes on the Metamodel and its SQL
----------------------------------

My meta-model merges mandatory, uniqueness and frequency
constraints into one "Presence Constraint" object. This
is because all three constraint types have to do with
the number of times a role or role sequence may be played.

For object types (Entity, Value and Objectified Facts),
I have separate classes in the Ruby API, but these are
absorbed into one ObjectType table in the SQL. This
allows proper referential integrity from the Role table.
A consequence is that in sample populations, the entity
instances and value instances are absorbed into one
Instance table as well, with a nullable Value field.

The metamodel supports sub-models and imported models,
allowing composition. It also supports units allowing
dimensional analysis for value types.

Future
------

Next on my list of tasks (not strictly in order) is:

* Complete testing of Ruby Constellation API and the Ruby
  code generator.

* Generate the Metamodel.orm to a new base API.

* Extend that API with the higher-level behaviour required
  by the ActiveFacts tools, making the tools work again (the
  NORMA file loader, generators, etc).

* Complete the Constellation Query Language DDL subset.

* Write the absorption code to transform an elementary semantic
  model down to a relational schema.

* Implement database persistence for generated APIs.

* Implement database persistence for the metamodel, to allow
  further progress on the web-based modeling tool I've started.

* Start translating CQL queries to call a conceptual query
  API, which will generate SQL and return a constellation.

* Redo the reverse engineering using Sequel or DataMapper to
  eliminate the dependence on AR, CPK and DRYSql.

* Further reverse engineer the ER (compound) schema to an
  elementary schema.

* Automatically generating database migration code to preserve
  and transform an existing database to match changes to the
  conceptual model.

Clifford Heath, clifford.heath@gmail.com.
